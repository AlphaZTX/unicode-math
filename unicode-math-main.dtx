
% \section{\DTXCURR --- Main package code}
%
%    \begin{macrocode}
%<*package&(XE|LU)>
%    \end{macrocode}
%
% \subsection{The main \cs{setmathfont} macro}
%
% Using a |range| including large character sets such as \cmd\mathrel,
% \cmd\mathalpha, \etc, is \emph{very slow}!
% I hope to improve the performance somehow.
%
% \begin{macro}{\setmathfont}
% \doarg{font features (first optional argument retained for backwards compatibility)}
% \darg{font name}
% \doarg{font features}
%    \begin{macrocode}
\DeclareDocumentCommand \setmathfont { O{} m O{} }
  {
    \@@_setmathfont:nn {#1,#3} {#2}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_set:Nn \@@_setmathfont:nn
 {
  \tl_set:Nn \l_@@_fontname_tl {#2}
  \@@_init:
%    \end{macrocode}
% Grab the current size information:
% (is this robust enough? Maybe it should be preceded by \cmd\normalsize).
% The macro \cmd\S@\meta{size}
% contains the definitions of the sizes used for maths letters, subscripts and subsubscripts in
% \cmd\tf@size, \cmd\sf@size, and \cmd\ssf@size, respectively.
%    \begin{macrocode}
  \cs_if_exist:cF { S@ \f@size } { \calculate@math@sizes }
  \csname S@\f@size\endcsname
%    \end{macrocode}
% Parse options and tell people what's going on:
%    \begin{macrocode}
  \keys_set_known:nnN {unicode-math} {#1} \l_@@_unknown_keys_clist
  \bool_if:NT \l_@@_init_bool { \@@_log:n {default-math-font} }
%    \end{macrocode}
% Use \pkg{fontspec} to select a font to use.
% After loading the font, we detect what sizes it recommends for scriptsize and scriptscriptsize, so after setting those values appropriately, we reload the font to take these into account.
%    \begin{macrocode}

%<debug>  \csname TIC\endcsname
  \@@_fontspec_select_font:
%<debug>  \csname TOC\endcsname
  \bool_if:nT { \l_@@_ot_math_bool && !\g_@@_mainfont_already_set_bool }
   {
    \@@_declare_math_sizes:
    \@@_fontspec_select_font:
   }
%    \end{macrocode}
% Now define |\@@_symfont_tl| as the \LaTeX\ math font to access everything:
%    \begin{macrocode}
  \cs_if_exist:cF { sym \@@_symfont_tl }
    {
      \DeclareSymbolFont{\@@_symfont_tl}
        {\encodingdefault}{\l_@@_family_tl}{\mddefault}{\updefault}
    }
  \SetSymbolFont{\@@_symfont_tl}{\l_@@_mversion_tl}
    {\encodingdefault}{\l_@@_family_tl}{\mddefault}{\updefault}
%    \end{macrocode}
% Set the bold math version.
%    \begin{macrocode}
  \tl_set:Nn \l_@@_tmpa_tl {normal}
  \tl_if_eq:NNT \l_@@_mversion_tl \l_@@_tmpa_tl
    {
     \SetSymbolFont{\@@_symfont_tl}{bold}
      {\encodingdefault}{\l_@@_family_tl}{\bfdefault}{\updefault}
    }
%    \end{macrocode}
% Declare the math sizes (i.e., scaling of superscripts) for the specific
% values for this font,
% and set defaults for math fams two and three for legacy compatibility:
%    \begin{macrocode}
  \bool_if:nT { \l_@@_ot_math_bool && !\g_@@_mainfont_already_set_bool }
   {
    \bool_set_true:N \g_@@_mainfont_already_set_bool
    \@@_setup_legacy_fam_two:
    \@@_setup_legacy_fam_three:
   }
%    \end{macrocode}
% And now we input every single maths char.
%    \begin{macrocode}
%<debug>  \csname TIC\endcsname
  \@@_input_math_symbol_table:
%<debug>  \csname TOC\endcsname
%    \end{macrocode}
% Finally,
% \begin{itemize}
% \item Remap symbols that don't take their natural mathcode
% \item Activate any symbols that need to be math-active
% \item Enable wide/narrow accents
% \item Assign delimiter codes for symbols that need to grow
% \item Setup the maths alphabets (\cs{mathbf} etc.)
% \end{itemize}
%    \begin{macrocode}
  \@@_remap_symbols:
  \@@_setup_mathactives:
  \@@_setup_delcodes:
%<debug>  \csname TIC\endcsname
  \@@_setup_alphabets:
%<debug>  \csname TOC\endcsname
  \@@_setup_negations:
%    \end{macrocode}
% Prevent spaces, and that's it:
%    \begin{macrocode}
  \ignorespaces
 }
%    \end{macrocode}
% \end{macro}
%
% Backward compatibility alias.
%    \begin{macrocode}
\cs_set_eq:NN \resetmathfont \setmathfont
%    \end{macrocode}
%
% \paragraph{Fall-back font}
%
% Want to load Latin Modern Math if nothing else.
% This needs to happen early so that all of the font-loading machinery executes before
% the other `AtBeginDocument' code.
%    \begin{macrocode}
\AtBeginDocument { \@@_load_lm_if_necessary: }
\cs_new:Nn \@@_load_lm_if_necessary:
  {
    \cs_if_exist:NF \l_@@_fontname_tl
      {
        % TODO: update this when lmmath-bold.otf is released
        \setmathfont{latinmodern-math.otf}[BoldFont={latinmodern-math.otf}]
        \bool_set_false:N \g_@@_mainfont_already_set_bool
      }
  }
%    \end{macrocode}
% Note that here we reset the `font already loaded' boolean so that a new font being set
% will do the right thing in terms of setting up defaults.
%
% TODO: need a better way to do this for the general case. (Maybe a `reset' command option?)
%
% \begin{macro}{\@@_init:}
%    \begin{macrocode}
\cs_new:Nn \@@_init:
 {
%    \end{macrocode}
% \begin{itemize}
% \item Initially assume we're using a proper OpenType font with unicode maths.
%    \begin{macrocode}
  \bool_set_true:N  \l_@@_ot_math_bool
%    \end{macrocode}
% \item Erase any conception \LaTeX\ has of previously defined math symbol fonts;
% this allows \cmd\DeclareSymbolFont\ at any point in the document.
%    \begin{macrocode}
  \cs_set_eq:NN \glb@currsize \scan_stop:
%    \end{macrocode}
% \item To start with, assume we're defining the font for every math symbol character.
%    \begin{macrocode}
  \bool_set_true:N \l_@@_init_bool
  \seq_clear:N \l_@@_char_range_seq
  \clist_clear:N \l_@@_char_nrange_clist
  \seq_clear:N \l_@@_mathalph_seq
  \seq_clear:N \l_@@_missing_alph_seq
%    \end{macrocode}
% \item By default use the `normal' math version.
%    \begin{macrocode}
  \tl_set:Nn \l_@@_mversion_tl {normal}
%    \end{macrocode}
% \item Other range initialisations.
%    \begin{macrocode}
  \tl_set:Nn \@@_symfont_tl {operators}
  \cs_set_eq:NN \_@@_sym:nnn \@@_process_symbol_noparse:nnn
  \cs_set_eq:NN \@@_set_mathalphabet_char:nnn \@@_mathmap_noparse:nnn
  \cs_set_eq:NN \@@_remap_symbol:nnn \@@_remap_symbol_noparse:nnn
  \cs_set_eq:NN \@@_maybe_init_alphabet:n \@@_init_alphabet:n
  \cs_set_eq:NN \@@_map_char_single:nn \@@_map_char_noparse:nn
  \cs_set_eq:NN \@@_assign_delcode:nn \@@_assign_delcode_noparse:nn
  \cs_set_eq:NN \@@_make_mathactive:nNN \@@_make_mathactive_noparse:nNN
%    \end{macrocode}
% \item Define default font features for the script and scriptscript font.
%    \begin{macrocode}
  \tl_set:Nn \l_@@_script_features_tl  {Style=MathScript}
  \tl_set:Nn \l_@@_sscript_features_tl {Style=MathScriptScript}
  \tl_set_eq:NN \l_@@_script_font_tl   \l_@@_fontname_tl
  \tl_set_eq:NN \l_@@_sscript_font_tl  \l_@@_fontname_tl
%    \end{macrocode}
% \end{itemize}
%    \begin{macrocode}
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_declare_math_sizes:}
% Set the math sizes according to the recommended font parameters:
%    \begin{macrocode}
\cs_new:Nn \@@_declare_math_sizes:
  {
%<*LU>
    \fp_compare:nF { \@@_script_style_size:n {ScriptPercentScaleDown} == 0 }
      {
        \DeclareMathSizes { \f@size } { \f@size }
          { \@@_script_style_size:n {ScriptPercentScaleDown} }
          { \@@_script_style_size:n {ScriptScriptPercentScaleDown} }
      }
%</LU>
%<*XE>
    \dim_compare:nF { \fontdimen 10 \l_@@_font == 0pt }
      {
        \DeclareMathSizes { \f@size } { \f@size }
          { \@@_fontdimen_to_scale:nn {10} {\l_@@_font} }
          { \@@_fontdimen_to_scale:nn {11} {\l_@@_font} }
      }
%</XE>
  }
%    \end{macrocode}
% \end{macro}
%
%<*LU>
% \begin{macro}{\@@_script_style_size:n}
% Determine script- and scriptscriptstyle sizes using luaotfload:
%   \begin{macrocode}
\cs_new:Nn \@@_script_style_size:n
  {
    \fp_eval:n {\directlua{tex.sprint(luaotfload.aux.get_math_dimension("l_@@_font","#1"))} * \f@size / 100 }
  }
%   \end{macrocode}
% \end{macro}
%</LU>
%
%
% \begin{macro}{\@@_setup_legacy_fam_two:}
% \TeX\ won't load the same font twice at the same scale, so we need to magnify this one by an imperceptable amount.
%    \begin{macrocode}
\cs_new:Nn \@@_setup_legacy_fam_two:
  {
    \fontspec_set_family:Nxn \l_@@_family_tl
      {
      \l_@@_font_keyval_tl,
      Scale=1.00001,
      FontAdjustment =
       {
        \fontdimen8\font= \@@_get_fontparam:nn {43} {FractionNumeratorDisplayStyleShiftUp}\relax
        \fontdimen9\font= \@@_get_fontparam:nn {42} {FractionNumeratorShiftUp}\relax
        \fontdimen10\font=\@@_get_fontparam:nn {32} {StackTopShiftUp}\relax
        \fontdimen11\font=\@@_get_fontparam:nn {45} {FractionDenominatorDisplayStyleShiftDown}\relax
        \fontdimen12\font=\@@_get_fontparam:nn {44} {FractionDenominatorShiftDown}\relax
        \fontdimen13\font=\@@_get_fontparam:nn {21} {SuperscriptShiftUp}\relax
        \fontdimen14\font=\@@_get_fontparam:nn {21} {SuperscriptShiftUp}\relax
        \fontdimen15\font=\@@_get_fontparam:nn {22} {SuperscriptShiftUpCramped}\relax
        \fontdimen16\font=\@@_get_fontparam:nn {18} {SubscriptShiftDown}\relax
        \fontdimen17\font=\@@_get_fontparam:nn {18} {SubscriptShiftDownWithSuperscript}\relax
        \fontdimen18\font=\@@_get_fontparam:nn {24} {SuperscriptBaselineDropMax}\relax
        \fontdimen19\font=\@@_get_fontparam:nn {20} {SubscriptBaselineDropMin}\relax
        \fontdimen20\font=0pt\relax % delim1 = FractionDelimiterDisplaySize
        \fontdimen21\font=0pt\relax % delim2 = FractionDelimiterSize
        \fontdimen22\font=\@@_get_fontparam:nn {15} {AxisHeight}\relax
       }
      } {\l_@@_fontname_tl}
    \SetSymbolFont{symbols}{\l_@@_mversion_tl}
      {\encodingdefault}{\l_@@_family_tl}{\mddefault}{\updefault}

    \tl_set:Nn \l_@@_tmpa_tl {normal}
    \tl_if_eq:NNT \l_@@_mversion_tl \l_@@_tmpa_tl
      {
      \SetSymbolFont{symbols}{bold}
        {\encodingdefault}{\l_@@_family_tl}{\bfdefault}{\updefault}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_setup_legacy_fam_three:}
% Similarly, this font is shrunk by an imperceptable amount for \TeX\ to load it again.
%    \begin{macrocode}
\cs_new:Nn \@@_setup_legacy_fam_three:
  {
    \fontspec_set_family:Nxn \l_@@_family_tl
      {
      \l_@@_font_keyval_tl,
      Scale=0.99999,
      FontAdjustment={
        \fontdimen8\font= \@@_get_fontparam:nn {48} {FractionRuleThickness}\relax
        \fontdimen9\font= \@@_get_fontparam:nn {28} {UpperLimitGapMin}\relax
        \fontdimen10\font=\@@_get_fontparam:nn {30} {LowerLimitGapMin}\relax
        \fontdimen11\font=\@@_get_fontparam:nn {29} {UpperLimitBaselineRiseMin}\relax
        \fontdimen12\font=\@@_get_fontparam:nn {31} {LowerLimitBaselineDropMin}\relax
        \fontdimen13\font=0pt\relax
      }
    } {\l_@@_fontname_tl}
    \SetSymbolFont{largesymbols}{\l_@@_mversion_tl}
      {\encodingdefault}{\l_@@_family_tl}{\mddefault}{\updefault}

    \tl_set:Nn \l_@@_tmpa_tl {normal}
    \tl_if_eq:NNT \l_@@_mversion_tl \l_@@_tmpa_tl
      {
      \SetSymbolFont{largesymbols}{bold}
        {\encodingdefault}{\l_@@_family_tl}{\bfdefault}{\updefault}
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%    \begin{macrocode}
\cs_new:Nn \@@_get_fontparam:nn
%<XE>  { \the\fontdimen#1\l_@@_font\relax }
%<LU>  { \directlua{fontspec.mathfontdimen("l_@@_font","#2")} }
%    \end{macrocode}
%
%
%
% \begin{macro}{\@@_fontspec_select_font:}
% Select the font with \cs{fontspec} and define \cs{l_@@_font} from it.
%    \begin{macrocode}
\cs_new:Nn \@@_fontspec_select_font:
 {
  \tl_set:Nx \l_@@_font_keyval_tl {
%<LU>     Renderer = Basic,
    BoldItalicFont = {}, ItalicFont = {},
    Script = Math,
    SizeFeatures =
     {
      {
       Size = \tf@size-
      } ,
      {
       Size = \sf@size-\tf@size ,
       Font = \l_@@_script_font_tl ,
       \l_@@_script_features_tl
      } ,
      {
       Size = -\sf@size ,
       Font = \l_@@_sscript_font_tl ,
       \l_@@_sscript_features_tl
      }
     } ,
    \l_@@_unknown_keys_clist
  }
  \fontspec_set_fontface:NNxn \l_@@_font \l_@@_family_tl
    {\l_@@_font_keyval_tl} {\l_@@_fontname_tl}
%    \end{macrocode}
% Check whether we're using a real maths font:
%    \begin{macrocode}
  \group_begin:
    \fontfamily{\l_@@_family_tl}\selectfont
    \fontspec_if_script:nF {math} {\bool_gset_false:N \l_@@_ot_math_bool}
  \group_end:
 }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Functions for setting up symbols with mathcodes}
% \seclabel{mathsymbol}
%
% \begin{macro}{\@@_process_symbol_noparse:nnn}
% \begin{macro}{\@@_process_symbol_parse:nnn}
% If the \feat{range} font feature has been used, then only
% a subset of the Unicode glyphs are to be defined.
% See \secref{rangeproc} for the code that enables this.
%    \begin{macrocode}
\cs_set:Nn \@@_process_symbol_noparse:nnn
 {
  \@@_set_mathsymbol:nNNn {\@@_symfont_tl} #2 #3 {#1}
 }
%    \end{macrocode}
%    \begin{macrocode}
\cs_set:Nn \@@_process_symbol_parse:nnn
 {
  \@@_if_char_spec:nNNT {#1} {#2} {#3}
   {
    \@@_process_symbol_noparse:nnn {#1} {#2} {#3}
   }
 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\@@_remap_symbols:}
% \begin{macro}{\@@_remap_symbol_noparse:nnn}
% \begin{macro}{\@@_remap_symbol_parse:nnn}
% This function is used to define the mathcodes for those chars which should
% be mapped to a different glyph than themselves.
%    \begin{macrocode}
\cs_new:Npn \@@_remap_symbols:
 {
  \@@_remap_symbol:nnn{`\-}{\mathbin}{"02212}% hyphen to minus
  \@@_remap_symbol:nnn{`\*}{\mathbin}{"02217}% text asterisk to "centred asterisk"
  \bool_if:NF \g_@@_literal_colon_bool
   {
    \@@_remap_symbol:nnn{`\:}{\mathrel}{"02236}% colon to ratio (i.e., punct to rel)
   }
 }
%    \end{macrocode}
% \end{macro}
% Where |\@@_remap_symbol:nnn| is defined to be one of these two, depending
% on the range setup:
%    \begin{macrocode}
\cs_new:Nn \@@_remap_symbol_parse:nnn
 {
  \@@_if_char_spec:nNNT {#3} {\@nil} {#2}
   { \@@_remap_symbol_noparse:nnn {#1} {#2} {#3} }
 }
\cs_new:Nn \@@_remap_symbol_noparse:nnn
 {
  \clist_map_inline:nn {#1}
   { \@@_set_mathcode:nnnn {##1} {#2} {\@@_symfont_tl} {#3} }
 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsubsection{Active math characters}
%
% There are more math active chars later in the subscript/superscript section.
% But they don't need to be able to be typeset directly.
%
% \begin{macro}{\@@_setup_mathactives:}
%    \begin{macrocode}
\cs_new:Npn \@@_setup_mathactives:
 {
  \@@_make_mathactive:nNN {"2032} \@@_prime_single_mchar \mathord
  \@@_make_mathactive:nNN {"2033} \@@_prime_double_mchar \mathord
  \@@_make_mathactive:nNN {"2034} \@@_prime_triple_mchar \mathord
  \@@_make_mathactive:nNN {"2057} \@@_prime_quad_mchar   \mathord
  \@@_make_mathactive:nNN {"2035} \@@_backprime_single_mchar \mathord
  \@@_make_mathactive:nNN {"2036} \@@_backprime_double_mchar \mathord
  \@@_make_mathactive:nNN {"2037} \@@_backprime_triple_mchar \mathord
  \@@_make_mathactive:nNN {`\'} \mathstraightquote \mathord
  \@@_make_mathactive:nNN {`\`} \mathbacktick      \mathord
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_make_mathactive:nNN}
% Makes |#1| a mathactive char, and gives cs |#2| the meaning of mathchar |#1|
% with class |#3|.
% You are responsible for giving active |#1| a particular meaning!
%    \begin{macrocode}
\cs_new:Nn \@@_make_mathactive_parse:nNN
  {
    \@@_if_char_spec:nNNT {#1} #2 #3
      { \@@_make_mathactive_noparse:nNN {#1} #2 #3 }
  }
\cs_new:Nn \@@_make_mathactive_noparse:nNN
  {
    \@@_set_mathchar:NNnn #2 #3 {\@@_symfont_tl} {#1}
    \@@_char_gmake_mathactive:n {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Delimiter codes}
%
%
% \begin{macro}{\@@_assign_delcode:nn}
%    \begin{macrocode}
\cs_new:Nn \@@_assign_delcode_noparse:nn
 {
  \@@_set_delcode:nnn \@@_symfont_tl {#1} {#2}
 }
\cs_new:Nn \@@_assign_delcode_parse:nn
 {
  \@@_if_char_spec:nNNT {#2} {\@nil} {\@nil}
   {
    \@@_assign_delcode_noparse:nn {#1} {#2}
   }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_assign_delcode:n}
% Shorthand.
%    \begin{macrocode}
\cs_new:Nn \@@_assign_delcode:n { \@@_assign_delcode:nn {#1} {#1} }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_setup_delcodes:}
% Some symbols that aren't mathopen/mathclose still need to have delimiter codes assigned.
% The list of vertical arrows may be incomplete.
% On the other hand, many fonts won't support them all being stretchy.
% And some of them are probably not meant to stretch, either. But adding them here doesn't hurt.
%    \begin{macrocode}
\cs_new:Npn \@@_setup_delcodes:
 {
  % ensure \left. and \right. work:
  \@@_set_delcode:nnn \@@_symfont_tl {`\.} {\c_zero}
  % this is forcefully done to fix a bug -- indicates a larger problem!

  \@@_assign_delcode:nn {`\/}   {\g_@@_slash_delimiter_usv}
  \@@_assign_delcode:nn {"2044} {\g_@@_slash_delimiter_usv} % fracslash
  \@@_assign_delcode:nn {"2215} {\g_@@_slash_delimiter_usv} % divslash
  \@@_assign_delcode:n {"005C} % backslash
  \@@_assign_delcode:nn {`\<} {"27E8} % angle brackets with ascii notation
  \@@_assign_delcode:nn {`\>} {"27E9} % angle brackets with ascii notation
  \@@_assign_delcode:n {"2191} % up arrow
  \@@_assign_delcode:n {"2193} % down arrow
  \@@_assign_delcode:n {"2195} % updown arrow
  \@@_assign_delcode:n {"219F} % up arrow twohead
  \@@_assign_delcode:n {"21A1} % down arrow twohead
  \@@_assign_delcode:n {"21A5} % up arrow from bar
  \@@_assign_delcode:n {"21A7} % down arrow from bar
  \@@_assign_delcode:n {"21A8} % updown arrow from bar
  \@@_assign_delcode:n {"21BE} % up harpoon right
  \@@_assign_delcode:n {"21BF} % up harpoon left
  \@@_assign_delcode:n {"21C2} % down harpoon right
  \@@_assign_delcode:n {"21C3} % down harpoon left
  \@@_assign_delcode:n {"21C5} % arrows up down
  \@@_assign_delcode:n {"21F5} % arrows down up
  \@@_assign_delcode:n {"21C8} % arrows up up
  \@@_assign_delcode:n {"21CA} % arrows down down
  \@@_assign_delcode:n {"21D1} % double up arrow
  \@@_assign_delcode:n {"21D3} % double down arrow
  \@@_assign_delcode:n {"21D5} % double updown arrow
  \@@_assign_delcode:n {"21DE} % up arrow double stroke
  \@@_assign_delcode:n {"21DF} % down arrow double stroke
  \@@_assign_delcode:n {"21E1} % up arrow dashed
  \@@_assign_delcode:n {"21E3} % down arrow dashed
  \@@_assign_delcode:n {"21E7} % up white arrow
  \@@_assign_delcode:n {"21E9} % down white arrow
  \@@_assign_delcode:n {"21EA} % up white arrow from bar
  \@@_assign_delcode:n {"21F3} % updown white arrow
 }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{(Big) operators}
%
% Turns out that \XeTeX\ is clever enough to deal with big operators for us
% automatically with \cmd\Umathchardef. Amazing!
%
% However, the limits aren't set automatically; that is, we want to define,
% a la Plain \TeX\ \etc, |\def\int{\intop\nolimits}|, so there needs to be a
% transformation from \cmd\int\ to \cmd\intop\ during the expansion of
% \cmd\_@@_sym:nnn\ in the appropriate contexts.
%
% \begin{macro}{\l_@@_nolimits_tl}
% This macro is a sequence containing those maths operators that require a
% \cmd\nolimits\ suffix.
% This list is used when processing |unicode-math-table.tex| to define such
% commands automatically (see the macro \cs{@@_set_mathsymbol:nNNn}).
% I've chosen essentially just the operators that look like integrals;
% hopefully a better mathematician can help me out here.
% I've a feeling that it's more useful \emph{not} to include the multiple
% integrals such as $\iiiint$, but that might be a matter of preference.
%    \begin{macrocode}
\tl_new:N \l_@@_nolimits_tl
\tl_set:Nn \l_@@_nolimits_tl
 {
  \int\iint\iiint\iiiint\oint\oiint\oiiint
  \intclockwise\varointclockwise\ointctrclockwise\sumint
  \intbar\intBar\fint\cirfnint\awint\rppolint
  \scpolint\npolint\pointint\sqint\intlarhk\intx
  \intcap\intcup\upint\lowint
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\addnolimits}
% This macro appends material to the macro containing the list of operators
% that don't take limits.
%    \begin{macrocode}
\DeclareDocumentCommand \addnolimits {m}
 {
  \tl_put_right:Nn \l_@@_nolimits_tl {#1}
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\removenolimits}
% Can this macro be given a better name?
% It removes an item from the nolimits list.
%    \begin{macrocode}
\DeclareDocumentCommand \removenolimits {m}
 {
  \tl_remove_all:Nn \l_@@_nolimits_tl {#1}
 }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Radicals}
%
% The radical for square root is organised in \cs{@@_set_mathsymbol:nNNn}.
% I think it's the only radical ever.
% (Actually, there is also \cs{cuberoot} and \cs{fourthroot}, but they don't
%  seem to behave as proper radicals.)
%
% Also, what about right-to-left square roots?
%
% \begin{macro}{\l_@@_radicals_tl}
% We organise radicals in the same way as nolimits-operators.
%    \begin{macrocode}
\tl_new:N \l_@@_radicals_tl
\tl_set:Nn \l_@@_radicals_tl {\sqrt \longdivision}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Maths accents}
%
% Maths accents should just work \emph{if they are available in the font}.
%
% \subsection{Common interface for font parameters}
%
% \XeTeX\ and \LuaTeX\ have different interfaces for math font parameters.
% We use \LuaTeX’s interface because it’s much better, but rename the primitives to be more \LaTeX3-like.
% There are getter and setter commands for each font parameter.
% The names of the parameters is derived from the \LuaTeX\ names, with underscores inserted between words.
% For every parameter \cs{Umath\meta{\LuaTeX\ name}}, we define an expandable getter command \cs{@@_\meta{\LaTeX3 name}:N} and a protected setter command \cs{@@_set_\meta{\LaTeX3 name}:Nn}.
% The getter command takes one of the style primitives (\cs{displaystyle} etc.)\ and expands to the font parameter, which is a \meta{dimension}.
% The setter command takes a style primitive and a dimension expression, which is parsed with \cs{dim_eval:n}.
%
% Often, the mapping between font dimensions and font parameters is bijective, but there are cases which require special attention:
% \begin{itemize}
% \item Some parameters map to different dimensions in display and non-display styles.
% \item Likewise, one parameter maps to different dimensions in non-cramped and cramped styles.
% \item There are a few parameters for which \XeTeX\ doesn’t seem to provide \cs{fontdimen}s; in this case the getter and setter commands are left undefined.
% \end{itemize}
%
% \paragraph{Cramped style tokens}
% \LuaTeX\ has \cs{crampeddisplaystyle} etc.,\ but they are loaded as \cs{luatexcrampeddisplaystyle} etc.\ by the \pkg{luatextra} package.
% \XeTeX, however, doesn’t have these primitives, and their syntax cannot really be emulated.
% Nevertheless, we define these commands as quarks, so they can be used as arguments to the font parameter commands (but nowhere else).
% Making these commands available is necessary because we need to make a distinction between cramped and non-cramped styles for one font parameter.
%
% \begin{macro}{\@@_new_cramped_style:N}
% \darg{command}
% Define \meta{command} as a new cramped style switch.
% For \LuaTeX, simply rename the correspronding primitive if it is not
% already defined.
% For \XeTeX, define \meta{command} as a new quark.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \@@_new_cramped_style:N
%<XE>  { \quark_new:N #1 }
%<LU>  {
%<LU>    \cs_if_exist:NF #1
%<LU>      { \cs_new_eq:Nc #1 { luatex \cs_to_str:N #1 } }
%<LU>  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\crampeddisplaystyle}
% \begin{macro}{\crampedtextstyle}
% \begin{macro}{\crampedscriptstyle}
% \begin{macro}{\crampedscriptscriptstyle}
% The cramped style commands.
%    \begin{macrocode}
\@@_new_cramped_style:N \crampeddisplaystyle
\@@_new_cramped_style:N \crampedtextstyle
\@@_new_cramped_style:N \crampedscriptstyle
\@@_new_cramped_style:N \crampedscriptscriptstyle
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \paragraph{Font dimension mapping}
% Font parameters may differ between the styles.
% \LuaTeX\ accounts for this by having the parameter primitives take a style token argument.
% To replicate this behavior in \XeTeX, we have to map style tokens to specific combinations of font dimension numbers and math fonts (\cs{textfont} etc.).
%
% \begin{macro}{\@@_font_dimen:Nnnnn}
% \darg{style token}
% \darg{font dimen for display style}
% \darg{font dimen for cramped display style}
% \darg{font dimen for non-display styles}
% \darg{font dimen for cramped non-display styles}
% Map math style to \XeTeX\ math font dimension.
% \meta{style token} must be one of the style switches (\cs{displaystyle}, \cs{crampeddisplaystyle}, \dots).
% The other parameters are integer constants referring to font dimension numbers.
% The macro expands to a dimension which contains the appropriate font dimension.
%    \begin{macrocode}
%<*XE>
  \cs_new_nopar:Npn \@@_font_dimen:Nnnnn #1 #2 #3 #4 #5 {
    \fontdimen
    \cs_if_eq:NNTF #1 \displaystyle {
      #2 \textfont
    } {
      \cs_if_eq:NNTF #1 \crampeddisplaystyle {
        #3 \textfont
      } {
        \cs_if_eq:NNTF #1 \textstyle {
          #4 \textfont
        } {
          \cs_if_eq:NNTF #1 \crampedtextstyle {
            #5 \textfont
          } {
            \cs_if_eq:NNTF #1 \scriptstyle {
              #4 \scriptfont
            } {
              \cs_if_eq:NNTF #1 \crampedscriptstyle {
                #5 \scriptfont
              } {
                \cs_if_eq:NNTF #1 \scriptscriptstyle {
                  #4 \scriptscriptfont
                } {
%    \end{macrocode}
% Should we check here if the style is invalid?
%    \begin{macrocode}
                  #5 \scriptscriptfont
                }
              }
            }
          }
        }
      }
    }
%    \end{macrocode}
% Which family to use?
%    \begin{macrocode}
    \c_two
  }
%</XE>
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Font parameters}
% This paragraph contains macros for defining the font parameter interface, as well as the definition for all font parameters known to \LuaTeX.
%
% \begin{macro}{\@@_font_param:nnnnn}
% \darg{name}
% \darg{font dimension for non-cramped display style}
% \darg{font dimension for cramped display style}
% \darg{font dimension for non-cramped non-display styles}
% \darg{font dimension for cramped non-display styles}
% This macro defines getter and setter functions for the font parameter \meta{name}.
% The \LuaTeX\ font parameter name is produced by removing all underscores and prefixing the result with |Umath|.
% The \XeTeX\ font dimension numbers must be integer constants.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \@@_font_param:nnnnn
%<*XE>
{
  \@@_font_param_aux:ccnnnn { @@_ #1 :N } { @@_set_ #1 :Nn }
    { #2 } { #3 } { #4 } { #5 }
}
%</XE>
%<*LU>
{
  \tl_set:Nn \l_@@_tmpa_tl { #1 }
  \tl_remove_all:Nn \l_@@_tmpa_tl { _ }
  \@@_font_param_aux:ccc { @@_ #1 :N } { @@_set_ #1 :Nn }
    { Umath \l_@@_tmpa_tl }
}
%</LU>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_font_param:nnn}
% \darg{name}
% \darg{font dimension for display style}
% \darg{font dimension for non-display styles}
% This macro defines getter and setter functions for the font parameter \meta{name}.
% The \LuaTeX\ font parameter name is produced by removing all underscores and prefixing the result with |Umath|.
% The \XeTeX\ font dimension numbers must be integer constants.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \@@_font_param:nnn
 {
  \@@_font_param:nnnnn { #1 } { #2 } { #2 } { #3 } { #3 }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_font_param:nn}
% \darg{name}
% \darg{font dimension}
% This macro defines getter and setter functions for the font parameter \meta{name}.
% The \LuaTeX\ font parameter name is produced by removing all underscores and prefixing the result with |Umath|.
% The \XeTeX\ font dimension number must be an integer constant.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \@@_font_param:nn
 {
  \@@_font_param:nnnnn { #1 } { #2 } { #2 } { #2 } { #2 }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_font_param:n}
% \darg{name}
% This macro defines getter and setter functions for the font parameter \meta{name}, which is considered unavailable in \XeTeX\@.
% The \LuaTeX\ font parameter name is produced by removing all underscores and prefixing the result with |Umath|.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \@@_font_param:n
%<XE>  { }
%<LU>  { \@@_font_param:nnnnn { #1 } { 0 } { 0 } { 0 } { 0 } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_font_param_aux:NNnnnn}
% \begin{macro}{\@@_font_param_aux:NNN}
% Auxiliary macros for generating font parameter accessor macros.
%    \begin{macrocode}
%<*XE>
\cs_new_protected_nopar:Nn \@@_font_param_aux:NNnnnn
  {
    \cs_new_nopar:Npn #1 ##1
     {
      \@@_font_dimen:Nnnnn ##1 { #3 } { #4 } { #5 } { #6 }
     }
    \cs_new_protected_nopar:Npn #2 ##1 ##2
     {
      #1 ##1 \dim_eval:n { ##2 }
     }
  }
\cs_generate_variant:Nn \@@_font_param_aux:NNnnnn { cc }
%</XE>
%<*LU>
\cs_new_protected_nopar:Nn \@@_font_param_aux:NNN
  {
    \cs_new_nopar:Npn #1 ##1
     {
      #3 ##1
     }
    \cs_new_protected_nopar:Npn #2 ##1 ##2
     {
      #3 ##1 \dim_eval:n { ##2 }
     }
  }
\cs_generate_variant:Nn \@@_font_param_aux:NNN { ccc }
%</LU>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% Now all font parameters that are listed in the \LuaTeX\ reference follow.
%    \begin{macrocode}
\@@_font_param:nn { axis } { 15 }
\@@_font_param:nn { operator_size } { 13 }
\@@_font_param:n { fraction_del_size }
\@@_font_param:nnn { fraction_denom_down } { 45 } { 44 }
\@@_font_param:nnn { fraction_denom_vgap } { 50 } { 49 }
\@@_font_param:nnn { fraction_num_up } { 43 } { 42 }
\@@_font_param:nnn { fraction_num_vgap } { 47 } { 46 }
\@@_font_param:nn { fraction_rule } { 48 }
\@@_font_param:nn { limit_above_bgap } { 29 }
\@@_font_param:n { limit_above_kern }
\@@_font_param:nn { limit_above_vgap } { 28 }
\@@_font_param:nn { limit_below_bgap } { 31 }
\@@_font_param:n { limit_below_kern }
\@@_font_param:nn { limit_below_vgap } { 30 }
\@@_font_param:nn { over_delimiter_vgap } { 41 }
\@@_font_param:nn { over_delimiter_bgap } { 38 }
\@@_font_param:nn { under_delimiter_vgap } { 40 }
\@@_font_param:nn { under_delimiter_bgap } { 39 }
\@@_font_param:nn { overbar_kern } { 55 }
\@@_font_param:nn { overbar_rule } { 54 }
\@@_font_param:nn { overbar_vgap } { 53 }
\@@_font_param:n { quad }
\@@_font_param:nn { radical_kern } { 62 }
\@@_font_param:nn { radical_rule } { 61 }
\@@_font_param:nnn { radical_vgap } { 60 } { 59 }
\@@_font_param:nn { radical_degree_before } { 63 }
\@@_font_param:nn { radical_degree_after } { 64 }
\@@_font_param:nn { radical_degree_raise } { 65 }
\@@_font_param:nn { space_after_script } { 27 }
\@@_font_param:nnn { stack_denom_down } { 35 } { 34 }
\@@_font_param:nnn { stack_num_up } { 33 } { 32 }
\@@_font_param:nnn { stack_vgap } { 37 } { 36 }
\@@_font_param:nn { sub_shift_down } { 18 }
\@@_font_param:nn { sub_shift_drop } { 20 }
\@@_font_param:n { subsup_shift_down }
\@@_font_param:nn { sub_top_max } { 19 }
\@@_font_param:nn { subsup_vgap } { 25 }
\@@_font_param:nn { sup_bottom_min } { 23 }
\@@_font_param:nn { sup_shift_drop } { 24 }
\@@_font_param:nnnnn { sup_shift_up } { 21 } { 22 } { 21 } { 22 }
\@@_font_param:nn { supsub_bottom_max } { 26 }
\@@_font_param:nn { underbar_kern } { 58 }
\@@_font_param:nn { underbar_rule } { 57 }
\@@_font_param:nn { underbar_vgap } { 56 }
\@@_font_param:n { connector_overlap_min }
%    \end{macrocode}
%
% \subsection{Resolving Greek symbol name control sequences}
%
% \begin{macro}{\@@_resolve_greek:}
% This macro defines \cmd\Alpha\dots\cmd\omega\ as their corresponding
% Unicode (mathematical italic) character. Remember that the mapping
% to upright or italic happens with the mathcode definitions, whereas these macros
% just stand for the literal Unicode characters.
%    \begin{macrocode}
\AtBeginDocument{\@@_resolve_greek:}
\cs_new:Npn \@@_resolve_greek:
 {
  \clist_map_inline:nn
   {
    Alpha,Beta,Gamma,Delta,Epsilon,Zeta,Eta,Theta,Iota,Kappa,Lambda,
    alpha,beta,gamma,delta,epsilon,zeta,eta,theta,iota,kappa,lambda,
    Mu,Nu,Xi,Omicron,Pi,Rho,Sigma,Tau,Upsilon,Phi,Chi,Psi,Omega,
    mu,nu,xi,omicron,pi,rho,sigma,tau,upsilon,phi,chi,psi,omega,
    varTheta,varsigma,vartheta,varkappa,varrho,varpi,varepsilon,varphi
   }
   {
    \tl_set:cx {##1} { \exp_not:c { mit ##1 } }
    \tl_set:cx {up ##1} { \exp_not:N \symup \exp_not:c { ##1 } }
    \tl_set:cx {it ##1} { \exp_not:N \symit \exp_not:c { ##1 } }
   }
 }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</package&(XE|LU)>
%    \end{macrocode}
%
\endinput
